function pinfo = EWE_DGM2D_PrecomputeUpwindFluxPNonConf(RunOptions,pinfo,Norder,rho,lambda,mu,DomainIndices,FluidDomainWithSolidLayer,Solid)

% EWE_DGM2D_PrecomputeUpwindFluxPNonConf.m precomputes variables required for
% the implementation of the acoustic forward problem using the elastic wave
% equation for p-nonconforming meshes. This is motivated by Timo Lahivaara's code
% and also utilizes codes from the textbook "Nodal Discontinous Galerkin Methods, Algorithms, Analysis and
% Applications" by Jan Hesthaven and Tim Warburton, 2007
%
% Inputs: 
%   RunOptions:
%          UseAcousticViaElasticDGMFormulation - Sets shear parameter to 0 for simulating acoustic wave propagation
%          StrainVelocityForm - Using strain-velocity formulation
%          StressVelocityForm - Using stress-velocity formulation
%   pinfo:
%          Np - Number of nodes per element in DGM grid
%          K - Number of elements
%          Nfp - number of face points
%          Fmask - local nodal indices for the edge nodes of an element
%   rho - Mass density per unit volume
%   lambda = Second Lame parameter
%   mu - First Lame parameter, also known as the shear modulus. Setting the shear modulus to zero yields the acoustic fluid wave equation
%   DomainIndices - N_Elm by 1 Structure generated by Trelis indicating which elements are in which side domains
%   FluidDomainWithSolidLayer - Boolean of material type; fluid with a solid layer
%   Solid - Boolean of material type; solid
%
%  Outputs:
%   pinfo:
%         A41_D_rho - Entry of matrix A divided by rho (if Strain-Velocity Form)
%         A42_D_rho - Entry of matrix A divided by rho (if Strain-Velocity Form)
%         B43_D_rho - Entry of matrix B divided by rho (if Strain-Velocity Form)
%         A14_D_rho - Entry of matrix A divided by rho (if Stress-Velocity Form)
%         A24_D_rho - Entry of matrix A divided by rho (if Stress-Velocity Form)
%         rhoM - interior mass density per unit volume
%         muM - interior first Lame parameter
%         lambdaM - interior first Lame parameter
%         cpM - interior P-wave speed
%         csM - interior S-wave speed
%         rhoP - exterior mass density per unit volume
%         muP - exterior first Lame parameter
%         lambdaP - exterior second Lame parameter
%         cpP - exterior P-wave speed
%         csP - exterior S-wave speed
%
% Hwan Goh, 3/01/2017 (Happy New Year!), University of Auckland, New Zealand
% Last Edited: 26/11/2017 (Happy birthday Lowe!) - Added DomainIndices and prepared function for fluid-solid mediums 
%
% Notes: For stress-velocity form, need to set up r1 vector for nonconforming meshes (line 131)

Nfaces = 3;

for N1=1:max(Norder)
    pinf = pinfo(N1);
    K = pinf.K;
    Np = pinf.Np;
    ids = pinf.ids;
    Fmask = pinf.Fmask;
    if K>0
        %% == Parameters ===%
        rho = rho(ids);
        mu = mu(ids);
        lambda = lambda(ids);
        % _T_ means .* and _P_ means + and _D_ means ./
        if RunOptions.StrainVelocityForm == 1
            pinfo(N1).A41_D_rho = (lambda + 2*mu)./rho;
            pinfo(N1).A42_D_rho = lambda./rho;
            pinfo(N1).B43_D_rho = 2*mu./rho;
            pinfo(N1).mu_D_rho = mu./rho;
            cp = sqrt(pinfo(N1).A41_D_rho);
            cs = sqrt(pinfo(N1).mu_D_rho);
        end
        if RunOptions.StressVelocityForm == 1
            pinfo(N1).A14_D_rho = (lambda + 2*mu)./rho;
            pinfo(N1).A24_D_rho = lambda./rho;
            pinfo(N1).mu_D_rho = mu./rho;
            cp = sqrt(pinfo(N1).A14_D_rho);
            cs = sqrt(pinfo(N1).mu_D_rho);
        end
        
        %% == Interior and Exterior Terms ===%
        rowFmask = Fmask(:);
        pinfo(N1).rhoM = rho(rowFmask,:);
        pinfo(N1).muM = mu(rowFmask,:);
        pinfo(N1).lambdaM = lambda(rowFmask,:);
        pinfo(N1).cpM = cp(rowFmask,:);
        pinfo(N1).csM = cs(rowFmask,:);
        pinfo(N1).rhoP = zeros(size(pinfo(N1).rhoM));
        pinfo(N1).muP = zeros(size(pinfo(N1).rhoM));
        pinfo(N1).lambdaP = zeros(size(pinfo(N1).rhoM));
        pinfo(N1).cpP = zeros(size(pinfo(N1).rhoM));
        pinfo(N1).csP = zeros(size(pinfo(N1).rhoM));
        for N2 = 1:length(pinfo)
            if ~isempty(pinf.fmapM{N2})
                interp = pinf.interpP{N2}; 
                fmapM = pinf.fmapM{N2}; 
                vmapP = pinf.vmapP{N2};
                tmpmat = repmat(vmapP(1,:),length(interp(:,1)),1);
                pinfo(N1).rhoP(fmapM) = rho(tmpmat);
                pinfo(N1).muP(fmapM) = mu(tmpmat);
                pinfo(N1).lambdaP(fmapM) = lambda(tmpmat);
                pinfo(N1).cpP(fmapM) = cp(tmpmat);
                pinfo(N1).csP(fmapM) = cs(tmpmat);
            end
        end
        
        %% == Flux Terms ===%
        %B_1(c_pM)
        for k = 1:K
            for i=1:Nfaces*pinf.Nfp
                divv1 = pinfo(N1).cpP(i,k)*(pinfo(N1).lambdaM(i,k)+2*pinfo(N1).muM(i,k)) + pinfo(N1).cpM(i,k)*(pinfo(N1).lambdaP(i,k)+2*pinfo(N1).muP(i,k));
                pinfo(N1).d11(i,k) = pinfo(N1).cpP(i,k)/divv1;
                pinfo(N1).d13(i,k) = (pinfo(N1).lambdaP(i,k)+2*pinfo(N1).muP(i,k))/divv1;
            end
        end
        %r_1M Vector
        if RunOptions.StrainVelocityForm == 1
            pinfo(N1).r1(:,:,1) = pinfo(N1).nxnx;
            pinfo(N1).r1(:,:,2) = pinfo(N1).nyny;
            pinfo(N1).r1(:,:,3) = pinfo(N1).nxny;
            pinfo(N1).r1(:,:,4) = pinfo(N1).cpM.*pinf.nx;
            pinfo(N1).r1(:,:,5) = pinfo(N1).cpM.*pinf.ny;
        end
        if RunOptions.StressVelocityForm == 1 %Needs to be modified for nonconforming meshes
            pinfo(N1).r1(:,:,1) = pinfo(N1).lambdaM + (2*pinfo(N1).muM).*pinfo(N1).nxnx;
            pinfo(N1).r1(:,:,2) = pinfo(N1).lambdaM + (2*pinfo(N1).muM).*pinfo(N1).nyny;
            pinfo(N1).r1(:,:,3) = (2*pinfo(N1).muM).*pinfo(N1).nxny;
            pinfo(N1).r1(:,:,4) = pinfo(N1).cpM.*pinf.nx;
            pinfo(N1).r1(:,:,5) = pinfo(N1).cpM.*pinf.ny;
        end
        
        %B_2(csM) which is 1/(p-c_s- + p+c_s+)
        pinfo(N1).B_2csM = zeros(3*pinfo(N1).Nfp,pinfo(N1).K);
        if RunOptions.UseTrelisMesh == 1 && FluidDomainWithSolidLayer == 1
            for ii = 1:pinfo(N1).K
                if DomainIndices(ii) == 1 || DomainIndices(ii) == 3
                    pinfo(N1).B_2csM(:,ii) = 0;
                end
                if DomainIndices(ii) == 2
                    pinfo(N1).B_2csM(:,ii) = 1./(pinfo(N1).rhoM(:,ii).*pinfo(N1).csM(:,ii) + pinfo(N1).rhoP(:,ii).*pinfo(N1).csP(:,ii));                                   
                end
            end
        else if Solid == 1; %if it's fluid, then leave all as zero
                pinfo(N1).B_2csM = 1./(pinfo(N1).rhoM.*pinfo(N1).csM + pinfo(N1).rhoP.*pinfo(N1).csP);
            end
        end
    end
end
              